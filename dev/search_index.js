var documenterSearchIndex = {"docs":
[{"location":"api/#StaticLLVM","page":"API Reference","title":"StaticLLVM","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Documentation for StaticLLVM","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#StaticLLVM.LLVMBlock","page":"API Reference","title":"StaticLLVM.LLVMBlock","text":"LLVMBlock(lable::Symbol, index::Int, ir::SubString{String})\n\nRepresents a basic block in LLVM IR with its label, index (order), and IR body.\n\nlabel::Symbol:Identifier for the LLVM IR block, e.g. :entry, :L3, etc.  \nindex::Int: The order of block in LLVM IR function.\nir::SubString{String}: A substring view of the whole block.\n\n\n\n\n\n","category":"type"},{"location":"api/#StaticLLVM.MethodInfo","page":"API Reference","title":"StaticLLVM.MethodInfo","text":"MethodInfo(m::Core.Method)\nMethodInfo(m::Core.Method, name::Symbol())\n\nA mutable struct that stores metadata and compiled LLVM IR information for a specific Julia method.\n\nFields\n\nname::Symbol: A user-friendly name for the method. Defaults to the mangled name if not provided.\nmangled::Symbol: The internal compiler name of the method, used for LLVM IR lookup.\narg_types::Tuple: A tuple of argument types (excluding the function type), derived from the method signature.\nmethod::Core.Method: The original Julia Method object\nllvm_ir::String: The LLVM IR code generated for the method, extracted as a string.\n\n\n\n\n\n","category":"type"},{"location":"api/#StaticLLVM.ModVarInfo","page":"API Reference","title":"StaticLLVM.ModVarInfo","text":"ModVarInfo(name::String, mod::Module, mangled::String, llvm_def::String, llvm_decl::String)\n\nHolds metadata for a module-level mutable variable (ModVar):\n\nname::Symbol        : Julia binding name\nfile::Symbol        : file of mod-vars\nmangled::String     : LLVM mangled global name\nllvm_def::String    : LLVM IR global variable definition\nllvm_decl::String   : LLVM IR external declaration\n\n\n\n\n\n","category":"type"},{"location":"api/#StaticLLVM.ModuleInfo","page":"API Reference","title":"StaticLLVM.ModuleInfo","text":"ModuleInfo\n\nStores metadata associated with a Julia Module, including referenced methods and  global module-level variables.\n\nFields\n\nmod::Module: The Julia module this information is associated with.\nmangled::String: The mangled name of the module, following the Itanium C++ ABI\nmodvars::IdSet{ModVarInfo}: A set of global static variables (ModVarInfo) used in this module. Identity-based (IdSet) to ensure uniqueness by object reference.\nmethods::Vector{MethodInfo}: A list of methods (MethodInfo) defined or referenced within this module.\n\nUsage\n\nModuleInfo is typically constructed internally during code analysis or code generation workflows to track both method definitions and global state referenced by a module.\n\n\n\n\n\n","category":"type"},{"location":"api/#StaticLLVM.assemble_modinfo-Tuple{Dict{String, Any}, IdDict{Method, Symbol}, IdDict{UInt64, StaticLLVM.ModVarInfo}}","page":"API Reference","title":"StaticLLVM.assemble_modinfo","text":"assemble_modinfo(config::Dict{String,Any}, method_map::IdDict{Core.Method,Symbol}, modvar_map::IdDict{UInt,ModVarInfo}, check_ir::Bool = true) -> IdDict{Module, ModuleInfo}\n\nConstructs ModuleInfo objects that capture method-level (MethodInfo) and global variable (ModVarInfo) metadata within each Julia module.\n\nEach entry in method_map is processed to generate a MethodInfo object containing LLVM IR and related properties.  Similarly, each global variable entry in modvar_map is assigned to the appropriate module. \n\nArguments\n\nconfig::Dict{String,Any}: Configuration dictionary. Must include keys like \"debug\" and \"policy\", controlling diagnostics and symbol filtering.\nmethod_map::IdDict{Core.Method,Symbol}: Maps Julia Method objects to their LLVM mangled symbol names.\nmodvar_map::IdDict{UInt,ModVarInfo}: Maps raw pointer addresses (as UInt) to their corresponding global variable metadata.\n\nLLVM IR policy Behavior\n\n:warn: Emits a warning if non-static LLVM IR is found.\n:strict: Throws an error.\n:strip: Attempts to strip the specific GC-related IR allocations\n:strip_all: Attempts to strip all GC-related IR allocations.\n\nReturns\n\nAn IdDict{Module, ModuleInfo} mapping each involved Julia Module to its assembled ModuleInfo representation, including static methods and module-level variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.build","page":"API Reference","title":"StaticLLVM.build","text":"build(mod::Module=Main, config::Dict=default_config())\n\nMain build process:\n\nParse arguments if called from Main.\nCollect global variables and method info.\nDump LLVM IR files.\nOptionally compile with clang.\n\nArguments\n\nmod: The module to process (defaults to Main).\nconfig: Build configuration dictionary.\n\nSupported compile modes:\n\n:none – Just generate IR\n:onefile – Compile all IR into a single binary\n:makefile – (Not implemented)\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticLLVM.clean_cache-Tuple{String}","page":"API Reference","title":"StaticLLVM.clean_cache","text":"clean_cache(path::String)\n\nDelete cached build files (e.g., .o, .so, .dll, .lib, .a, .dylib) under the given directory. This is useful for cleaning intermediate or compiled files before a fresh build.\n\nArguments\n\npath: Directory where cache files are stored.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.collect_methods!","page":"API Reference","title":"StaticLLVM.collect_methods!","text":"collect_methods!(name_map::IdDict{Method, Symbol}, method::Method)\n\nRecursively collect methods starting from method, ensuring all are precompiled and mapped to mangled names. This function avoids use of global state by requiring an explicit name map to be passed in.\n\nArguments\n\nmethod::Method: The starting method to process.\nname_map::IdDict{Method, Symbol}: A dictionary to store original methods and their original names.\n\nBehavior\n\nEnsures the method is precompiled.\nStores a mapping from the method to its mangled name.\nRecursively processes Core.MethodInstance objects found in method.roots.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticLLVM.collect_modvar_pairs-Tuple{Module}","page":"API Reference","title":"StaticLLVM.collect_modvar_pairs","text":"collect_modvars(mod::Module) -> Vector{Tuple{Int, ModVarInfo}}\n\nRecursively collects all mutable, constant global variables defined in a Julia module mod  (excluding functions, types, and strings), and returns a list of (pointer, ModVarInfo) pairs.\n\nEach ModVarInfo contains:\n\nthe original symbol name\nthe module it belongs to\nits mangled LLVM symbol name\nits LLVM IR definition and declaration\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.compile_llvm_files-Tuple{Dict}","page":"API Reference","title":"StaticLLVM.compile_llvm_files","text":"compile_llvm_files(config::Dict)\n\nCompile all LLVM IR files in a specified directory into a single output binary.\n\nExpected keys in config:\n\n\"module\": Name of the output executable.\n\"dir\": Directory containing .ll files.\n\"clang\": Path to clang compiler.\n\"cflag\": Compiler flags (as a single string, e.g. \"-O2 -flto\").\n\nPrints status messages and compilation result.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.dump_llvm_ir-Tuple{StaticLLVM.ModuleInfo, String, Bool}","page":"API Reference","title":"StaticLLVM.dump_llvm_ir","text":"dump_llvm_ir(modinfo::ModuleInfo, output_dir::String, check::Bool)\n\nWrite LLVM IR files for a given ModuleInfo instance.\n\nWrites the IR of static module variables into one file named after the module.\nWrites the IR for each method individually into separate files.\nSkips writing files if content is unchanged (if check is true).\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.emit_llvm","page":"API Reference","title":"StaticLLVM.emit_llvm","text":"emit_llvm(fn::Function, args::Union{Tuple, Nothing}=nothing; clean::Bool=true, dump::Bool=true) -> String\n\nGenerate LLVM IR for a specific method of a Julia function specialized on given argument types.\n\nArguments\n\nfn: Julia function whose LLVM IR is requested.\nargs: Tuple of argument types specifying the method specialization;          if nothing, expect exactly one method for fn.\nclean: Remove extraneous comments and optionally add header if true (default: true).\ndump: Include full LLVM module in output if true (default: true).\n\nReturns\n\nLLVM IR string of the matched method, optionally cleaned.\n\nBehavior\n\nIf args is provided, use which to find the exact method.\nIf args is nothing, expect fn to have exactly one method, or throw an error.\nDelegates actual IR emission to another emit_llvm method accepting a Method.\n\nExample\n\nir = emit_llvm(sin, (Float64,); clean=true, dump=false)\nprintln(ir)\n\nadd(x::Int) = x + 1\nir = emit_llvm(add)\nprintln(ir)\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticLLVM.emit_llvm-Tuple{Method}","page":"API Reference","title":"StaticLLVM.emit_llvm","text":"emit_llvm(method::Core.Method; clean::Bool=true, dump::Bool=true) -> String\n\nGenerate the LLVM IR for a given Julia method.\n\nArguments\n\nmethod: The Core.Method object to generate LLVM IR for.\nclean: If true, strip comments and optionally prepend a header comment. Default is true.\ndump: If true, include the full LLVM module in the output. Default is true.\n\nReturns\n\nA string containing the LLVM IR of the method. When clean is true, comments are stripped.\n\nDetails\n\nExtracts the function instance and argument types from the method signature.\nUses InteractiveUtils.code_llvm to get the LLVM IR as a string.\nOptionally cleans the IR by removing comments using strip_comments.\nWhen cleaning, adds the method signature as a header comment.\n\nExample\n\nir = emit_llvm(my_method, clean=true, dump=false)\nprintln(ir)\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.emit_native","page":"API Reference","title":"StaticLLVM.emit_native","text":"emit_native(fn::Function, args::Union{Tuple, Nothing}=nothing; clean::Bool=true, dump::Bool=true) -> String\n\nGenerate native LLVM assembly for a specific method of a Julia function given argument types.\n\nArguments\n\nfn: Julia function whose LLVM IR is requested.\nargs: Tuple of argument types specifying the method specialization;          if nothing, expect exactly one method for fn.\nclean: Remove extraneous comments and optionally add header if true (default: true).\ndump: Include full LLVM module in output if true (default: true).\n\nReturns\n\nA string containing the native LLVM assembly code.\nWhen clean is true, comments and debug info are removed.\n\nBehavior\n\nIf args is provided, use which to find the exact method.\nIf args is nothing, expect fn to have exactly one method, or throw an error.\nDelegates actual IR emission to another emit_llvm method accepting a Method.\n\nExample\n\nir = emit_native(sin, (Float64,); clean=true, dump=false)\nprintln(ir)\n\nadd(x::Int) = x + 1\nir = emit_native(add)\nprintln(ir)\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticLLVM.emit_native-Tuple{Method}","page":"API Reference","title":"StaticLLVM.emit_native","text":"emit_native(method::Core.Method; clean::Bool=true, dump::Bool=true) -> String\n\nGenerate the native LLVM bitcode (assembly) for a given Julia method.\n\nArguments\n\nmethod: The Core.Method to generate native code for.\nclean: If true, remove comments and debug info from the output. Default is true.\ndump: If true, include the full module dump. Default is true.\n\nReturns\n\nA string containing the native LLVM assembly code.\nWhen clean is true, comments and debug info are removed.\n\nDetails\n\nExtracts the function instance and argument types from the method signature.\nCalls InteractiveUtils.code_native to get native LLVM assembly.\nControls debug info level: :none if clean, otherwise :default.\nOptionally cleans the output by stripping comments.\n\nExample\n\nnative_ir = emit_native(my_method, clean=true, dump=false)\nprintln(native_ir)\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.extract_llvm","page":"API Reference","title":"StaticLLVM.extract_llvm","text":"extract_llvm(method::Core.Method, ir::String; main::Bool=false) -> String\n\nExtract and clean up the LLVM IR of a single Julia-compiled function from the full IR string ir.\n\nArguments\n\nmethod::Core.Method: The Julia method to locate in the LLVM IR.\nir::String: The full LLVM IR text to search within.\nmain::Bool=false: If true, rename the function to @main, otherwise use the Julia function name.\n\nReturns\n\nString: A cleaned and rewritten IR block for the requested function, including global constants and necessary declarations.\n\nNotes\n\nHandles name mangling in @julia_<funcname>_<id> style.\nRewrites global constant names for uniqueness.\nGathers required declare lines and LLVM attributes for external linkage.\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticLLVM.find_matching_brace","page":"API Reference","title":"StaticLLVM.find_matching_brace","text":"find_matching_brace(s::String, start_pos::Int=1) -> Int\n\nFinds the index of the closing brace '}' that matches the first opening brace '{'  found at or after start_pos in the string s.\n\nReturns the index of the matching closing brace, or -1 if:\n\nNo opening brace is found at or after start_pos, or\nBraces are unbalanced and a match can't be found.\n\nArguments\n\ns: The input string to search.\nstart_pos: The position in the string to start searching from (1-based). Defaults to 1.\n\nExample\n\nfind_matching_brace(\"a{b{c}d}e\")  # returns 9\nfind_matching_brace(\"abc\", 1)     # returns -1\n\n\n\n\n\n","category":"function"},{"location":"api/#StaticLLVM.get_arg_types-Tuple{Method}","page":"API Reference","title":"StaticLLVM.get_arg_types","text":"get_arg_types(m::Core.Method) -> Tuple\n\nExtracts the argument types (excluding the function itself) from the method's signature.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.get_config-Tuple{}","page":"API Reference","title":"StaticLLVM.get_config","text":"get_config(; kwargs...) -> Dict{String, Any}\n\nReturn a copy of the default config, with optional keyword overrides.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.get_mod_filepath-Tuple{Module}","page":"API Reference","title":"StaticLLVM.get_mod_filepath","text":"get_mod_filepath(mod::Module) -> Symbol\n\nRetrieve the source file path symbol where the given module mod is defined.\n\nArguments\n\nmod::Module : The Julia module to inspect.\n\nReturns\n\nSymbol : The source file path as a Symbol if found.\n\nBehavior\n\nChecks if the module has a special field :_source_file_ and returns it if present.\nOtherwise, scans module names (excluding some built-ins) to find a function defined solely in this module and returns the file path of that function's method.\nThrows an error if no suitable source file path is found.\n\nNotes\n\nSkips imported names and private names starting with #.\nExcludes names like :eval and :include to avoid common standard functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.is_static_code-Tuple{String}","page":"API Reference","title":"StaticLLVM.is_static_code","text":"is_static_code(ir::String)::Bool\n\nDetermines whether the given LLVM IR string is \"static\", i.e., free from dynamic symbols or Julia internal functions.\n\nReturns\n\ntrue if the IR contains no known dynamic patterns.\nfalse if any non-static signature (like @ijl_) is found.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.load_pkg-Tuple{Dict{String, Any}}","page":"API Reference","title":"StaticLLVM.load_pkg","text":"load_pkg() -> Module\n\nLoad a Julia package or source file specified by the first command-line argument (ARGS[1]).\n\nBehavior\n\nIf ARGS[1] is a file path, includes the file and extracts the package name from the filename.\nOtherwise, attempts to import the package by name.\nIf import fails and a directory with the package name exists, tries to include the source file under ./<package>/src/<package>.\nRaises an error if the package cannot be found or loaded.\nOptionally, uses ARGS[2] as the module name to return; defaults to the package name.\n\nReturns\n\nThe loaded Julia module.\n\nNotes\n\nDepends on global ARGS array (command line arguments).\nPrints status messages indicating loading steps.\n\nExample\n\n```bash julia script.jl MyPackage OptionalModuleName\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.make_modvar_def-Union{Tuple{T}, Tuple{T, Bool}} where T","page":"API Reference","title":"StaticLLVM.make_modvar_def","text":"make_modvar_def(name::String, value::T, is_const::Bool = false) -> (String, String)\n\nGenerate LLVM IR global variable definition and external declaration strings for a Julia module variable.\n\nname: The variable name to be used in LLVM IR (as @name).\nvalue: The Julia module variable value to represent.\nis_const: If true, the LLVM global is marked constant; otherwise, it's mutable (global).\n\nReturns a tuple (definition::String, declaration::String) where:\n\ndefinition is the LLVM IR global definition string with initialization.\ndeclaration is the LLVM IR external global declaration string.\n\nSupported Julia types for value:\n\nFloating point: Float64, Float32\nInteger types: Int8, Int16, Int32, Int64, Int128 and unsigned equivalents\nBool\nPtr types\nString\nImmutable bitstypes (non-primitive)\n\nThrows an error if the type is unsupported.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.patch_memory_alloc!-Tuple{StaticLLVM.LLVMBlock, Vector{Pair{SubString{String}, UInt64}}}","page":"API Reference","title":"StaticLLVM.patch_memory_alloc!","text":"patch_memory_alloc!(block::LLVMBlock, type_map::Vector{Pair{String, Int}}) -> Bool\n\nReplaces the LLVM IR code that performs allocation via jl_alloc_genericmemory with explicit malloc or calloc instructions, based on whether the allocated type is mutable or abstract.\n\nArguments\n\nblock: An LLVMBlock containing the IR code.\ntype_map: A list of Pair{String, Int}, mapping type IDs (e.g., \"GenericMemory#1222\")  to an integer flag (0 = mutable/abstract, 1 = concrete/immutable).\n\nReturns\n\ntrue if the replacement occurred, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.patch_memory_instance!-Tuple{IdDict{Symbol, StaticLLVM.LLVMBlock}, StaticLLVM.LLVMBlock}","page":"API Reference","title":"StaticLLVM.patch_memory_instance!","text":"patch_memory_instance!(blocks_map::Dict{Symbol, LLVMBlock}, block::LLVMBlock) -> Bool\n\nPatch the LLVM IR of a block to replace a specific Core.GenericMemory atomic load instruction and simplify its associated conditional branch logic.\n\nArguments\n\nblocks_map: A dictionary mapping basic block names (as Symbol) to LLVMBlock objects.\nblock: The LLVM block whose IR may contain a Core.GenericMemory load instruction.\n\nReturns\n\ntrue if the block was modified, false otherwise.\n\nDescription\n\nThis function searches for a specific pattern in the LLVM IR indicating the use of a  hard-coded atomic load from Core.GenericMemory#<id>.jit. If found, the instruction is replaced with a cast from a globally defined pointer @GenericMemoryInstance. The jump logic immediately following the load is also simplified to jump unconditionally to the \"success\" label.\n\nThis is a low-level IR patching utility meant to canonicalize memory access logic.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.pyprint-Tuple","page":"API Reference","title":"StaticLLVM.pyprint","text":"pyprint(args...; sep=\" \", tail=\"\n\n\")\n\nPrint multiple arguments joined by a separator and ending with a specified tail string.\n\nArguments\n\nargs...: A variable number of arguments to be printed.\nsep: Separator string inserted between arguments. Default is a single space \" \".\ntail: String appended at the end of the output. Default is newline `\"\n\n\"`.\n\nBehavior\n\nConverts all arguments to strings.\nJoins them with the separator.\nPrints the resulting string followed by the tail string.\n\nExample\n\npyprint(\"Hello\", \"world\", 123; sep=\", \", tail=\"!\n\")\n# Output: Hello, world, 123!\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.recover_heap_object-Tuple{Integer}","page":"API Reference","title":"StaticLLVM.recover_heap_object","text":"recover_heap_object(addr::Integer) -> Any\n\nGiven a raw address (e.g. from pointer_from_objref), attempts to reconstruct the original Julia object stored at that memory location.\n\nThis function inspects the memory layout:\n\nIf the tag indicates a String, reconstruct it.\nIf the tag seems to point to a valid heap-allocated DataType, rehydrate the object.\n\nReturns nothing if the tag is not recognizable or unsupported.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.recover_heap_object-Tuple{Ptr}","page":"API Reference","title":"StaticLLVM.recover_heap_object","text":"recover_heap_object(p::Ptr) -> Any\n\nLow-level internal logic to reconstruct a Julia object from a raw pointer p. This inspects the memory tag to determine the type of the object.\n\nUsed internally by recover_heap_object.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.remove_memoryref_calls-Tuple{StaticLLVM.LLVMBlock}","page":"API Reference","title":"StaticLLVM.remove_memoryref_calls","text":"remove_memoryref_calls(block::LLVMBlock) -> Bool\n\nScans the LLVM IR in block and removes all lines that match calls to @memoryref. Returns true if any modifications were made.\n\nArguments\n\nblock: The LLVMBlock to process.\n\nReturns\n\ntrue if the block's IR was modified, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.remove_substrings-Tuple{AbstractString, Vector{Tuple{Int64, Int64}}}","page":"API Reference","title":"StaticLLVM.remove_substrings","text":"remove_substrings(input_str::AbstractString, ranges::Vector{Tuple{Int, Int}}) -> String\n\nRemoves substrings from input_str specified by the list of ranges.\n\nArguments\n\ninput_str: The original string.\nranges: A vector of (start, stop) index tuples indicating substrings to remove.\n\nReturns\n\nA new string with the specified substrings removed.\n\nExample\n\nremove_substrings(\"Hello, world!\", [(1,5), (8,8)]) # returns \", orld!\"\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.replace_memory_alloc-Tuple{StaticLLVM.MethodInfo}","page":"API Reference","title":"StaticLLVM.replace_memory_alloc","text":"replace_memory_alloc(method::MethodInfo)\n\nScans and patches LLVM IR in the given method to replace  allocations related to Core.GenericMemory. \n\nThis function:\n\nExtracts memory layout sizes for GenericMemory types from method metadata.\nIterates over all LLVM functions in the method, splits them into blocks.\nFor each block, attempts to patch GenericMemory instances and allocations, and removes calls to @memoryref.\nFinally updates the LLVM IR in the method with the patched blocks.\n\nArguments\n\nmethod: A MethodInfo struct containing LLVM IR and metadata.\n\nNotes\n\nRelies on low-level unsafe pointer operations to inspect Julia internal data.\nEmits a warning if element size exceeds 256 bytes.\nThrows an error if no GenericMemory alias is found.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.run_command-Tuple{Cmd}","page":"API Reference","title":"StaticLLVM.run_command","text":"run_command(cmd::Cmd; verbose::Bool=false) -> NamedTuple\n\nRun the given command and capture its output.\n\nArguments\n\ncmd: A Cmd object representing the system command to execute.\nverbose: If true, prints the command before execution.\n\nReturns\n\nA named tuple (success, code, output):\n\nsuccess: true if the command succeeded, false otherwise.\ncode: Exit code (0 if success, -1 if error caught).\noutput: Command output or error message as a string.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.split_blocks-Tuple{AbstractString}","page":"API Reference","title":"StaticLLVM.split_blocks","text":"split_blocks(ir::AbstractString) -> Vector{LLVMBlock}\n\nSplits a full LLVM IR string into a list of LLVMBlock objects, based on labeled basic blocks (e.g., entry:, L3:).\n\nArguments\n\nir: A string containing LLVM IR code.\n\nReturns\n\nA vector of LLVMBlock objects, each representing a labeled block of IR code.\n\nExample\n\nblocks = split_blocks(ir_string)\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.strip_comments-Tuple{String}","page":"API Reference","title":"StaticLLVM.strip_comments","text":"strip_comments(ir::String) -> String\n\nRemoves comments and trailing whitespace from LLVM IR code lines, while preserving  leading indentation and empty lines with no code content.\n\nArguments\n\nir: A multiline string containing LLVM IR code.\n\nReturns\n\nA new string where each line has comments (starting with ;) and trailing spaces removed.\nLines that contain only whitespace or comments are omitted.\n\nDetails\n\nThe function splits the input text into lines.\nFor each line, it finds the first comment delimiter ;.\nIt keeps only the part of the line before the comment.\nTrailing whitespace is trimmed, but leading whitespace (indentation) is preserved.\nEmpty or whitespace-only lines after stripping are skipped.\nThe resulting lines are joined back with newline characters.\n\nExample\n\ncode = \"\"\"\ndefine i32 @main() {\n  %1 = add i32 1, 2 ; addition\n  ret i32 %1 ; return value\n}\n\"\"\"\nprintln(strip_comments(code))\n# Output:\n# define i32 @main() {\n#   %1 = add i32 1, 2\n#   ret i32 %1\n# }\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.strip_gc_allocations-Tuple{String}","page":"API Reference","title":"StaticLLVM.strip_gc_allocations","text":"strip_gc_allocations(ir::String)::String\n\nClean up Julia IR by removing GC-related stack management and replacing @ijl_gc_pool_alloc_instrumented calls with standard malloc calls for further IR-level optimization or analysis.\n\nArguments\n\nir::String: The input LLVM IR string generated by Julia.\n\nReturns\n\nA cleaned-up IR string with GC stack frames and pool allocation calls removed or replaced.\n\n\n\n\n\n","category":"method"},{"location":"api/#StaticLLVM.write_if_changed-Tuple{String, String, Bool}","page":"API Reference","title":"StaticLLVM.write_if_changed","text":"write_if_changed(filepath::String, content::String, check::Bool)::Int\n\nWrites content to filepath only if the file content has changed or doesn't exist. If check is false, no writing occurs.\n\nReturns\n\n1 if the file was written (or would be written).\n0 if no writing was done due to check == false.\n\n\n\n\n\n","category":"method"},{"location":"#StaticLLVM.jl","page":"Home","title":"StaticLLVM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StaticLLVM.jl provides a lightweight framework for analyzing and modifying LLVM IR generated from Julia internal functions. It enables transformations on Julia-emitted IR by identifying and replacing specific constructs—such as GC-related instructions or Julia intrinsics—with standard equivalents like malloc, printf, etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"🚧 Note: This project is under active development. Many components are experimental or incomplete. Feedback and contributions are welcome!","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Features","page":"Home","title":"✨ Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🔧 LLVM IR Generation: Compile Julia functions to LLVM IR using Julia’s internal compiler pipeline.\n🧠 IR Transformation Engine:\nDetect and replace specific internal Julia functions (e.g., GC calls).\nInsert detected module-level variables (globals/constants) into the IR.\nSubstitute Julia intrinsics with standard C library calls (e.g., malloc, printf).\nEliminate or simplify GC-related instructions.\n🧹 IR Cleanup and Optimization:\nStrip unnecessary metadata and simplify the IR.\nPrepare IR for external linking or embedding in native runtimes.\n📦 Minimal Replacement Library (planned):\nProvide C-style implementations of selected Julia intrinsics for standalone use.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using StaticLLVM\nusing YourPackageName\nbuild(YourPackageName.some_module)","category":"page"},{"location":"#Prerequisites","page":"Home","title":"Prerequisites","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia (currently tested on v1.11.5)\nClang or compatible compiler (e.g., Intel oneAPI, AMD compiler)","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# ------ Example.jl ------\nmodule Example\n    using StaticTools\n\n    function fib(n::Int)::Int\n        n <= 1 && return 1\n        n == 2 && return 1\n        return fib(n - 1) + fib(n - 2)\n    end\n\n    const n_global = Ref(5)\n\n    function _main_(n::Int)::Int\n        n += n_global[]\n        arr = Array{Int, 1}(undef, n)\n        @inbounds for i in 1:n\n            arr[i] = fib(i)\n        end\n        for i in eachindex(arr)\n            @inbounds printf(\"fib[%d] = %d\\n\", i, arr[i])\n        end\n        return 0\n    end\nend\n\nExample._main_(3)\n# ------ make.jl ------\n\nusing StaticLLVM\n\n# include(\"Example.jl\") or using Example\n\nconfig = StaticLLVM.get_config(;\n    dir = \".\",                  # Working directory\n    compile_mode = :onefile,    # Compile all LLVM .ll files into a single binary\n    clean_cache = false,        # Keep intermediate cached files\n    debug = false,              # Dump raw LLVM IR as `.debug_ll`\n    policy = :strip_all         # Strip GC code and use `malloc` for memory allocation\n    clang => \"clang\",           # Path to the clang compiler\n    cflag => \"-O3 -g -Wall\",    # Flags passed to clang for optimization and warnings\n)\n\nbuild(Example, config)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus, a standalone program Example is generated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"> Example 1\nfib[1] = 1\nfib[2] = 1\nfib[3] = 2\nfib[4] = 3\nfib[5] = 5\nfib[6] = 8\nfib[7] = 13","category":"page"},{"location":"","page":"Home","title":"Home","text":"In practice:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define your program as a Julia module.\nUse include(...) or using to load the module.\nRun build(MyModule, config) to generate and optionally compile the LLVM IR.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The _main_() function will be used as the LLVM program entry point.","category":"page"}]
}
